{"instruction": "Define SCX for a checkout flow with auth, cart, quote, pay, and log.", "input": "", "output": "#user (>) @auth \"login\"\n#user (>) $cart \"add:product:seed-kit-01\"\n@pricing (>) \"? quote:seed-kit-01\"\n#user (>) $wallet \"spend:49\"\n%db.logs (+) { event:\"checkout_success\", actor:\"#user\", time:*now }", "tags": ["commerce", "auth", "payments", "scx"]}
{"instruction": "Define SCX for a user registration flow with validation and welcome.", "input": "", "output": "#visitor (>) @auth \"register:email:pass\"\n@auth (>) %db.users (+) { id:\"u_new\", role:\"member\" }\n@mailer (>) \"send:welcome:u_new\"\n!ui (>) \"open:dashboard\"\n%db.logs (+) { event:\"registration\", actor:\"#visitor\", time:*now }", "tags": ["commerce", "auth", "scx"]}
{"instruction": "Define SCX for an inventory transfer between two players.", "input": "", "output": "#player_a (>) $inventory \"remove:item:plasma-rifle\"\n#player_b (>) $inventory \"add:item:plasma-rifle\"\n%db.trades (+) { from:\"#player_a\", to:\"#player_b\", item:\"plasma-rifle\", time:*now }\n!ui (>) \"notify:trade-complete\"", "tags": ["commerce", "scx", "actions"]}
{"instruction": "Define SCX for a multi-step crafting recipe with resource checks.", "input": "", "output": "@crafting (>) \"? check:resources:#player:recipe-stimpak\"\n#player (>) $inventory \"remove:item:antiseptic:2\"\n#player (>) $inventory \"remove:item:steel:1\"\n@crafting (>) $inventory (+) { item:\"stimpak\", qty:1, crafter:\"#player\" }\n%db.logs (+) { event:\"craft\", actor:\"#player\", recipe:\"stimpak\", time:*now }", "tags": ["commerce", "scx", "actions"]}
{"instruction": "Define SCX for a faction reputation update after a quest.", "input": "", "output": "#player (>) @quest \"complete:quest-042\"\n%db.reputation (∂) { faction:\"brotherhood\", delta:+15, actor:\"#player\" }\n%db.reputation (∂) { faction:\"raiders\", delta:-5, actor:\"#player\" }\n@rewards (>) $wallet \"add:token:ASX:100\"\n!ui (>) \"notify:quest-complete:quest-042\"", "tags": ["scx", "actions", "runtime"]}
{"instruction": "Return an ASX block implementing `nav-bar` with a Vault-Tec clean style.", "input": "", "output": "<asx-block id=\"nav-bar\">\n  <div class=\"flex row gap-md bg-panel pad-md\">\n    <button class=\"border\" scx=\"!ui (>) 'open:inventory'\">Inventory</button>\n    <button class=\"border\" scx=\"!ui (>) 'open:map'\">Map</button>\n    <button class=\"border\" scx=\"!ui (>) 'open:agents'\">Agents</button>\n  </div>\n</asx-block>", "tags": ["asx-block", "ui", "html"]}
{"instruction": "Return an ASX block implementing `two-col-grid` with a Vault-Tec clean style.", "input": "", "output": "<asx-block id=\"two-col-grid\">\n  <div class=\"flex row gap-lg\">\n    <div class=\"col bg-panel pad-md\">[Left Panel]</div>\n    <div class=\"col bg-panel pad-md\">[Right Panel]</div>\n  </div>\n</asx-block>", "tags": ["asx-block", "ui", "html"]}
{"instruction": "Return an ASX block implementing `holotape-dock` with a Vault-Tec clean style.", "input": "", "output": "<asx-block id=\"holotape-dock\">\n  <div class=\"bg-panel pad-md text-md\">HOLOTAPE: <span bind=\"tape.name\"></span></div>\n</asx-block>", "tags": ["asx-block", "ui", "html"]}
{"instruction": "Return an ASX block implementing a status bar showing player health, caps, and location.", "input": "", "output": "<asx-block id=\"status-bar\">\n  <div class=\"flex row gap-md bg-panel pad-sm\">\n    <span class=\"text-accent\" bind=\"player.health\">HP: --</span>\n    <span class=\"text-accent\" bind=\"player.caps\">CAPS: --</span>\n    <span class=\"text-sm\" bind=\"player.location\">LOC: --</span>\n  </div>\n</asx-block>", "tags": ["asx-block", "ui", "html"]}
{"instruction": "Return an ASX block implementing a chat message list with agent attribution.", "input": "", "output": "<asx-block id=\"chat-log\">\n  <div class=\"col gap-sm bg-dark pad-md\" style=\"max-height:400px;overflow-y:auto\">\n    <div class=\"bg-panel pad-sm text-sm\" each=\"msg in chat.messages\">\n      <span class=\"text-accent\" bind=\"msg.agent\"></span>: <span bind=\"msg.text\"></span>\n    </div>\n  </div>\n</asx-block>", "tags": ["asx-block", "ui", "html"]}
{"instruction": "Return an ASX block implementing an agent roster panel.", "input": "", "output": "<asx-block id=\"agent-roster\">\n  <div class=\"col gap-sm bg-panel pad-md\">\n    <div class=\"text-lg text-accent\">Active Agents</div>\n    <div class=\"flex row gap-sm\" each=\"a in agents.active\">\n      <span class=\"border pad-sm text-sm\" bind=\"a.name\"></span>\n      <span class=\"text-sm\" bind=\"a.state\"></span>\n    </div>\n  </div>\n</asx-block>", "tags": ["asx-block", "ui", "html"]}
{"instruction": "Emit SCX lines to achieve the described intent.", "input": "Intent: update UI, persist settings, route to agent, and log the action.", "output": "!hud (>) \"notify:settings-saved\"\n%local.settings (∂) theme = \"dark\"\n#player (>) ^mx2cline \"plan task\"\n%db.logs (+) { event:\"settings_update\", actor:\"#player\", time:*now }", "tags": ["scx", "actions", "runtime"]}
{"instruction": "Emit SCX lines to achieve the described intent.", "input": "Intent: spawn an NPC, assign patrol behavior, and register in zone.", "output": "@spawner (>) &wasteland (+) { type:\"npc\", id:\"guard_07\" }\n#guard_07 (>) ^janus \"patrol:route-alpha\"\n&zone_central (+) { entity:\"#guard_07\", role:\"patrol\" }\n%db.entities (+) { id:\"guard_07\", spawned:*now }", "tags": ["scx", "actions", "runtime"]}
{"instruction": "Emit SCX lines to achieve the described intent.", "input": "Intent: broadcast alert to all agents in a zone and lock the zone.", "output": "&sector_9 (>) \"broadcast:alert:intruder\"\n^janus (>) \"pause:all:sector_9\"\n&sector_9 (∂) state = \"lockdown\"\n%db.logs (+) { event:\"lockdown\", zone:\"sector_9\", time:*now }", "tags": ["scx", "actions", "runtime"]}
{"instruction": "Emit SCX lines to achieve the described intent.", "input": "Intent: agent reads sensor data, infers threat level, updates UI.", "output": "^mx2qwen (>) @sensors \"read:thermal:sector_3\"\n^mx2qwen (>) \"infer:threat-level:high\"\n!hud (>) \"warn:threat-detected:sector_3\"\n%db.logs (+) { event:\"threat_infer\", agent:\"^mx2qwen\", level:\"high\", time:*now }", "tags": ["scx", "actions", "runtime", "ai"]}
{"instruction": "Provide atomic CSS utilities for layout and theming (no frameworks).", "input": "", "output": ".text-sm{font-size:.85rem}\n.text-md{font-size:1rem}\n.text-lg{font-size:1.35rem}\n.pad-sm{padding:6px}\n.pad-md{padding:12px}\n.pad-lg{padding:24px}\n.flex{display:flex}\n.row{flex-direction:row}\n.col{flex-direction:column}\n.gap-sm{gap:6px}\n.gap-md{gap:12px}\n.gap-lg{gap:20px}\n.bg-dark{background:#0b0e12;color:#E6F1FF}\n.bg-panel{background:#11161c;border-radius:10px}\n.text-accent{color:#7cd3ff}\n.border{border:1px solid #23303d;border-radius:8px}\n.center{align-items:center;justify-content:center}", "tags": ["css", "atomic", "utilities"]}
{"instruction": "Provide atomic CSS utilities for grid layouts and responsive breakpoints.", "input": "", "output": ".grid{display:grid}\n.grid-2{grid-template-columns:repeat(2,1fr)}\n.grid-3{grid-template-columns:repeat(3,1fr)}\n.grid-4{grid-template-columns:repeat(4,1fr)}\n.span-2{grid-column:span 2}\n.span-full{grid-column:1/-1}\n@media(max-width:768px){.grid-2,.grid-3,.grid-4{grid-template-columns:1fr}}\n.w-full{width:100%}\n.h-full{height:100%}\n.overflow-auto{overflow:auto}\n.overflow-hidden{overflow:hidden}\n.relative{position:relative}\n.absolute{position:absolute}\n.sticky{position:sticky;top:0}", "tags": ["css", "atomic", "utilities"]}
{"instruction": "Create a minimal ASXR HTML that mounts nav, grid, and holotape dock.", "input": "", "output": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"css/atomic.css\">\n    <script src=\"asx-runtime.js\" defer></script>\n  </head>\n  <body class=\"bg-dark pad-lg\">\n    <asx-block id=\"nav-bar\"></asx-block>\n    <asx-block id=\"two-col-grid\"></asx-block>\n    <asx-block id=\"holotape-dock\"></asx-block>\n  </body>\n</html>", "tags": ["asxr", "bootstrap", "html"]}
{"instruction": "Create an ASXR page with a studio-mode multi-panel layout for agent monitoring.", "input": "", "output": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"css/atomic.css\">\n    <script src=\"asx-runtime.js\" defer></script>\n    <script src=\"studio-connector.js\" defer></script>\n  </head>\n  <body class=\"bg-dark pad-lg\">\n    <div class=\"grid grid-3 gap-md\">\n      <asx-block id=\"agent-roster\"></asx-block>\n      <asx-block id=\"chat-log\" class=\"span-2\"></asx-block>\n      <asx-block id=\"status-bar\" class=\"span-full\"></asx-block>\n    </div>\n  </body>\n</html>", "tags": ["asxr", "bootstrap", "html", "studio"]}
{"instruction": "Given these brain files, show the SCX that queries them in order bigram then trigram then meta-intent.", "input": "{\n  \"bigrams.json\": {\n    \"enemy spotted\": \"seek cover\",\n    \"low health\": \"request healing\",\n    \"resource scarce\": \"search supply\",\n    \"user login\": \"verify credentials\",\n    \"cart update\": \"recalculate totals\"\n  },\n  \"trigrams.json\": {\n    \"night approaching quickly\": \"secure shelter\",\n    \"territory contested heavily\": \"reinforce boundary\",\n    \"checkout payment failed\": \"retry or offer alt\",\n    \"new user registration\": \"send welcome packet\"\n  },\n  \"meta-intent-map.json\": {\n    \"aggression\": [\"flank\", \"push_line\", \"breach\"],\n    \"defense\": [\"fortify\", \"patrol\", \"monitor\"],\n    \"trade\": [\"barter\", \"request\", \"craft\"],\n    \"commerce\": [\"cart_add\", \"checkout\", \"refund\"],\n    \"auth\": [\"login\", \"logout\", \"refresh_token\"]\n  }\n}", "output": "^mx2qwen (>) bigrams \"enemy spotted\"\n^janus (>) trigrams \"night approaching quickly\"\n^mx2cline (>) meta-intent \"commerce\"", "tags": ["brains", "ngrams", "agents"]}
{"instruction": "Given sealed brain files for the UI domain, show the SCX that routes a layout change through bigram, trigram, and intent resolution.", "input": "{\n  \"bigrams.json\": {\n    \"layout change\": 0.95,\n    \"component render\": 0.93,\n    \"theme switch\": 0.91,\n    \"panel resize\": 0.89\n  },\n  \"trigrams.json\": {\n    \"layout grid responsive\": 0.94,\n    \"component mount lifecycle\": 0.92,\n    \"theme dark toggle\": 0.90\n  },\n  \"intents.json\": {\n    \"layout\": {\"targets\": [\"LayoutMicronaut\"], \"confidence\": 0.96, \"verbs\": [\"grid\", \"flex\", \"split\", \"stack\"]}\n  }\n}", "output": "^ui_brain (>) bigrams \"layout change\"\n^ui_brain (>) trigrams \"layout grid responsive\"\n^LayoutMicronaut (>) intent \"layout\" { verb:\"grid\", confidence:0.96 }", "tags": ["brains", "ngrams", "agents", "micronaut"]}
{"instruction": "Explain the SCX sigil system and provide an example using all sigil types.", "input": "", "output": "SCX sigils map entity types to single characters:\n  # = actors (players, NPCs, factions)\n  @ = services (auth, pricing, mailer)\n  $ = wallets/inventories (cart, wallet, inventory)\n  % = databases/state stores (db.logs, db.users, local.settings)\n  ! = UI elements (hud, toast, menu, ui)\n  & = zones/spaces (sector_9, room_01, wasteland)\n  ^ = agents/AI (mx2qwen, janus, mx2cline)\n\nOperators:\n  (>) = trigger/send\n  (+) = create/append\n  (∂) = mutate\n\nExample using all sigils:\n  #player (>) @auth \"login\"\n  #player (>) $wallet \"spend:50\"\n  %db.logs (+) { event:\"purchase\", actor:\"#player\" }\n  !hud (>) \"notify:purchase-complete\"\n  &market (∂) state = \"active\"\n  ^janus (>) \"plan:restock\"", "tags": ["scx", "reference", "sigils"]}
{"instruction": "Write SCX to model a WebSocket connection lifecycle: connect, authenticate, subscribe, receive, disconnect.", "input": "", "output": "#client (>) @ws \"connect:wss://api.example.com\"\n@ws (>) @auth \"token:verify:jwt_abc123\"\n@ws (>) \"subscribe:channel:market-feed\"\n@ws (>) #client \"data:{ price:42.50, ticker:ASX }\"\n#client (>) @ws \"disconnect\"\n%db.logs (+) { event:\"ws_session\", actor:\"#client\", duration:\"120s\", time:*now }", "tags": ["scx", "network", "websocket"]}
{"instruction": "Write SCX for an HTTP REST API call: GET request, parse response, update state.", "input": "", "output": "#app (>) @http \"GET:https://api.example.com/v1/status\"\n@http (>) #app \"response:{ status:200, body:{ alive:true, uptime:86400 } }\"\n%local.cache (∂) api_status = { alive:true, uptime:86400 }\n!status-panel (>) \"update:api-online\"\n%db.logs (+) { event:\"api_check\", status:200, time:*now }", "tags": ["scx", "network", "http"]}
{"instruction": "Write SCX for file system operations: read a config, validate, write output.", "input": "", "output": "@fs (>) \"read:/config/app.toml\"\n@fs (>) #app \"data:{ port:3000, mode:production }\"\n@validator (>) \"check:config:schema-v1\"\n@fs (>) \"write:/output/compiled.json:{ port:3000, mode:production }\"\n%db.logs (+) { event:\"config_compile\", path:\"/output/compiled.json\", time:*now }", "tags": ["scx", "filesystem", "actions"]}
{"instruction": "Write SCX to connect to a local folder, scan contents, and project to UI.", "input": "Target: /home/user/project", "output": "@fs (>) \"scan:/home/user/project\"\n@fs (>) #app \"listing:{ files:[\"README.md\",\"src/\",\"package.json\"], count:3 }\"\n!file-browser (>) \"mount:/home/user/project\"\n!file-browser (>) \"render:tree\"\n%local.state (∂) connected_folder = \"/home/user/project\"", "tags": ["scx", "filesystem", "connector"]}
{"instruction": "Describe the SCX operator encoding for SCXQ2 control lanes.", "input": "", "output": "SCXQ2 operators map SCX symbolic operators to single-byte codes:\n\n  (>)  Trigger   0xA1  — send/route/invoke\n  (∂)  Mutate    0xA2  — modify existing state\n  (+)  Create    0xA3  — append/insert new data\n  (=)  Assign    0xA4  — set value directly\n\nEach operator occupies 1 byte in the lane record.\nOperator semantics are identical across SCXQ2 and SCXQ4.", "tags": ["scxq2", "reference", "encoding"]}
{"instruction": "Describe the SCXQ2 domain ID mapping.", "input": "", "output": "SCXQ2 domains map SCX sigil-class to single-byte IDs:\n\n  Geometry        & → 0x01\n  Graph/Topology  @ → 0x02\n  Tensor/Field    % → 0x03\n  Agent/Behavior  # → 0x04\n  UI/Presentation ! → 0x05\n\nEach domain ID occupies the first byte of a lane record.\nThe lane interpreter reads this byte to route to the correct domain engine.", "tags": ["scxq2", "reference", "encoding"]}
{"instruction": "Convert an SCX geometry mutation into a SCXQ2 lane.", "input": "&entity.position (∂) = [12,4,0]", "output": "Lane record:\n  Domain:     0x01 (Geometry)\n  Op:         0xA2 (Mutate)\n  Flags:      0x00 (Local effect)\n  TargetID:   [entity_id as u32]\n  PayloadLen: 0x0C (12 bytes)\n  Payload:    0x03 [float32(12.0)] [float32(4.0)] [float32(0.0)]\n\nHex: 01 A2 00 [4B target] 000C 03 41400000 40800000 00000000", "tags": ["scxq2", "lanes", "geometry"]}
{"instruction": "Convert an SCX agent action into a SCXQ2 lane.", "input": "#actor (>) ^planner \"scan\"", "output": "Lane record:\n  Domain:     0x04 (Agent)\n  Op:         0xA1 (Trigger)\n  Flags:      0x01 (Agent domain)\n  TargetID:   [actor_id as u32]\n  PayloadLen: 0x03 (3 bytes)\n  Payload:    0x04 [tokenID for \"scan\" as u16]\n\nHex: 04 A1 01 [4B target] 0003 04 [2B token]\n\nThe \"scan\" string is stored in the dictionary block and referenced by token ID.", "tags": ["scxq2", "lanes", "agent"]}
{"instruction": "Convert an SCX UI state change into a SCXQ2 lane.", "input": "!ui (>) \"open:inventory\"", "output": "Lane record:\n  Domain:     0x05 (UI/Presentation)\n  Op:         0xA1 (Trigger)\n  Flags:      0x02 (UI projection)\n  TargetID:   [ui_id as u32]\n  PayloadLen: 0x03 (3 bytes)\n  Payload:    0x04 [tokenID for \"open:inventory\" as u16]\n\nHex: 05 A1 02 [4B target] 0003 04 [2B token]\n\nThe action token \"open:inventory\" is dictionary-indexed.", "tags": ["scxq2", "lanes", "ui"]}
{"instruction": "Convert an SCX graph edge creation into a SCXQ2 lane.", "input": "@nodeA → @nodeB", "output": "Lane record:\n  Domain:     0x02 (Graph/Topology)\n  Op:         0xA3 (Create)\n  Flags:      0x00 (Local effect)\n  TargetID:   [nodeA_id as u32]\n  PayloadLen: 0x05 (5 bytes)\n  Payload:    0x05 [nodeB_id as u32]\n\nHex: 02 A3 00 [4B nodeA] 0005 05 [4B nodeB]\n\nCreates a directed edge from nodeA to nodeB in the topology graph.", "tags": ["scxq2", "lanes", "graph"]}
{"instruction": "Convert an SCX tensor weight update into a SCXQ2 lane.", "input": "%tensor.weights[3][4] (∂) = 0.92", "output": "Lane record:\n  Domain:     0x03 (Tensor/Field)\n  Op:         0xA2 (Mutate)\n  Flags:      0x04 (Persistent)\n  TargetID:   [tensor_id as u32]\n  PayloadLen: 0x0B (11 bytes)\n  Payload:    0x06 0x02 [u16(3)] [u16(4)] 0x01 [float32(0.92)]\n\nPayload breakdown:\n  0x06 = TensorIndex type\n  0x02 = 2 dimensions\n  index(3), index(4)\n  0x01 = Scalar float follows\n  float32(0.92) = 0x3F6B851F", "tags": ["scxq2", "lanes", "tensor"]}
{"instruction": "Write a complete SCXQ2 packet with header, dictionary, and 3 lanes.", "input": "Actions: move entity to [5,0,3], trigger agent scan, update UI.", "output": "SCXQ2 Packet:\n\n== Header (16 bytes) ==\n  Magic:          SCX2 (0x53 0x43 0x58 0x32)\n  Version:        0x01\n  Flags:          0x00 (uncompressed)\n  DictCount:      0x0002 (2 entries)\n  LaneCount:      0x00000003 (3 lanes)\n  MetadataOffset: 0x00000000 (no metadata)\n\n== Dictionary ==\n  0x0001 | 0x04 | \"scan\"\n  0x0002 | 0x0E | \"open:inventory\"\n\n== Lane 1: Geometry Mutate ==\n  01 A2 00 [entityID] 000C 03 [float5][float0][float3]\n\n== Lane 2: Agent Trigger ==\n  04 A1 01 [agentID] 0003 04 0001\n\n== Lane 3: UI Trigger ==\n  05 A1 02 [uiID] 0003 04 0002", "tags": ["scxq2", "lanes", "packet", "binary"]}
{"instruction": "Describe SCXQ2 lane flags and their meanings.", "input": "", "output": "SCXQ2 lane flags (1 byte, bitfield):\n\n  0x00  Local effect     — mutation stays within local runtime\n  0x01  Agent domain     — lane targets agent/behavior subsystem\n  0x02  UI projection    — lane drives UI state, no persistent mutation\n  0x04  Persistent       — mutation is snapshot-recorded\n  0x08  Network broadcast — lane replicates to connected runtimes\n\nFlags can be combined: 0x05 = Persistent + Agent domain.\nThe interpreter checks flags after applying the operator to determine scope.", "tags": ["scxq2", "reference", "flags"]}
{"instruction": "Explain SCXQ2 payload encoding types.", "input": "", "output": "SCXQ2 payload types (first byte of payload):\n\n  0x01  Scalar float   — 4 bytes, IEEE-754\n  0x02  Scalar int     — 4 bytes, big-endian\n  0x03  Vector3        — 3 × float32 (12 bytes)\n  0x04  TokenRef       — 2 bytes, dictionary token ID\n  0x05  NodeRef        — 4 bytes, graph node ID\n  0x06  TensorIndex    — 2B dim count + variable indices\n  0x07  Struct         — nested key-value entries\n\nPayload length is declared in the lane header (PayloadLen, 2 bytes).\nAll multi-byte values are big-endian.", "tags": ["scxq2", "reference", "encoding"]}
{"instruction": "Describe the SCXQ2 lane packing binary format header.", "input": "", "output": "SCXQ2 Header (16 bytes total):\n\n  Offset  Size  Field           Value/Description\n  0x00    4B    Magic           \"SCX2\" (0x53 0x43 0x58 0x32)\n  0x04    1B    Version         Format version (0x01)\n  0x05    1B    Flags           Compression: 0x01=GZIP, 0x02=ZSTD, 0x04=Encrypted\n  0x06    2B    DictCount       Number of dictionary entries (big-endian u16)\n  0x08    4B    LaneCount       Number of lanes (big-endian u32)\n  0x0C    4B    MetadataOffset  Byte offset to optional metadata block\n\nRuntimes read the header first, then load the dictionary, then stream lanes sequentially.", "tags": ["scxq2", "binary", "format"]}
{"instruction": "Describe the SCXQ2 dictionary block format.", "input": "", "output": "SCXQ2 Dictionary Block:\n\nSequence of entries immediately after the 16-byte header.\nEach entry:\n  [ TokenID (2B, u16) | Length (1B, u8) | UTF-8 bytes (Length bytes) ]\n\nExample:\n  0x0001 | 0x04 | \"scan\"\n  0x0002 | 0x0F | \"open:inventory\"\n  0x0003 | 0x08 | \"position\"\n\nRules:\n  - Token IDs in range 0x0400+ (registry-assigned composites)\n  - No duplicate token IDs within a packet\n  - Dictionary must be fully loaded before lane processing\n  - Big-endian for all multi-byte fields", "tags": ["scxq2", "binary", "format"]}
{"instruction": "Describe the SCXQ4 lane header structure and how it differs from SCXQ2.", "input": "", "output": "SCXQ4 Lane Header (fixed 16 bytes):\n\n  Field       Size   Description\n  Domain      1B     Domain ID (same as SCXQ2: 0x01-0x05)\n  Opcode      2B     Operator code (big-endian, same semantics as SCXQ2)\n  Flags       1B     Scope flags (same bit layout as SCXQ2)\n  TargetID    8B     Big-endian u64 (SCXQ2 uses 4B u32)\n  PayloadLen  4B     Big-endian u32 (SCXQ2 uses 2B u16)\n\nKey differences from SCXQ2:\n  - TargetID: 64-bit vs 32-bit (global sparse address space)\n  - PayloadLen: u32 vs u16 (max 4GB vs 64KB payload)\n  - Opcode: 2B vs 1B (wider opcode table)\n  - Total header: 16B vs ~9B", "tags": ["scxq4", "binary", "format"]}
{"instruction": "Explain the SCXQ2 to SCXQ4 lifting law.", "input": "", "output": "SCXQ2 → SCXQ4 Lifting Law:\n\nAny valid SCXQ2 lane can be deterministically lifted to SCXQ4:\n\n  Domain      → copied as-is (1B)\n  Opcode      → zero-extend 1B to 2B (0xA1 → 0x00A1)\n  Flags       → copied as-is (1B)\n  TargetID_32 → zero-extend to TargetID_64 (4B → 8B)\n  PayloadLen  → zero-extend u16 to u32 (2B → 4B)\n  Payload     → copied as-is\n\nInvariant: lifting then decoding yields identical semantics.\n\nDowncasting SCXQ4 → SCXQ2 is legal only if:\n  - High 32 bits of TargetID_64 are zero\n  - PayloadLen_32 ≤ 65535\n  - Opcode high byte is 0x00", "tags": ["scxq4", "scxq2", "lifting", "reference"]}
{"instruction": "Convert an SCX geometry mutation into a SCXQ4 lane.", "input": "&entity.position (∂) = [12,4,0]", "output": "SCXQ4 Lane record (16B header + payload):\n\n  Domain:     0x01 (Geometry)\n  Opcode:     0x00A2 (Mutate, 2 bytes)\n  Flags:      0x00 (Local effect)\n  TargetID:   [entity_id as u64, 8 bytes]\n  PayloadLen: 0x0000000D (13 bytes)\n  Payload:    0x03 [float32(12.0)] [float32(4.0)] [float32(0.0)]\n\nCompared to SCXQ2:\n  - TargetID is 8 bytes instead of 4\n  - PayloadLen is 4 bytes instead of 2\n  - Opcode is 2 bytes instead of 1\n  - Semantics are identical", "tags": ["scxq4", "lanes", "geometry"]}
{"instruction": "Explain SCXQ4 64-bit TargetID address space partitioning.", "input": "", "output": "SCXQ4 TargetID is a big-endian u64 interpreted as a global sparse address space.\n\nRecommended partitioning (policy level, not enforced by lane law):\n\n  Bits 63-48: Universe / cluster / authority ID\n  Bits 47-32: Domain-specific ID space\n  Bits 31-0:  Local object index\n\nExample:\n  0x0001_0002_00000042\n  │     │     └── Local entity #66\n  │     └── Domain 0x0002 (Graph)\n  └── Cluster 0x0001\n\nInvariant: a given (Domain, TargetID) pair must refer to the same\nlogical entity across all compliant runtimes.", "tags": ["scxq4", "reference", "addressing"]}
{"instruction": "Write a SCXQ4 lane stream for a multi-cluster game state update.", "input": "Move entity in cluster 1, create graph edge in cluster 2, update tensor in cluster 3.", "output": "SCXQ4 Lane Stream (3 lanes, no padding between lanes):\n\n== Lane 1: Geometry Mutate (Cluster 1) ==\n  01 00A2 00 0001_0001_00000001 0000000D\n  03 [float(10.0)] [float(5.0)] [float(0.0)]\n\n== Lane 2: Graph Create (Cluster 2) ==\n  02 00A3 00 0002_0002_0000000A 00000005\n  05 [u32(nodeB_local_id)]\n\n== Lane 3: Tensor Mutate (Cluster 3) ==\n  03 00A2 04 0003_0003_00000007 0000000B\n  06 02 [u16(3)] [u16(4)] 01 [float32(0.92)]\n\nEach lane carries its cluster identity in the high bits of TargetID.\nThe stream is deterministic and replayable.", "tags": ["scxq4", "lanes", "multi-cluster"]}
{"instruction": "Describe Micronaut SCO/1 lifecycle states and transitions.", "input": "", "output": "Micronaut lifecycle states:\n\n  INIT → READY → RUNNING → IDLE → HALT\n\nValid transitions:\n  INIT    → READY     (initialization complete, brains loaded)\n  READY   → RUNNING   (first chat.txt message received)\n  RUNNING → IDLE      (no input for idle-timeout period)\n  IDLE    → RUNNING   (new input arrives)\n  RUNNING → HALT      (explicit halt command or fatal error)\n  IDLE    → HALT      (explicit halt command)\n\nInvalid transitions (rejected):\n  HALT → any          (terminal state, no restart)\n  RUNNING → INIT      (no re-initialization)\n  READY → HALT        (must run first)\n\nThe PowerShell orchestrator enforces transitions via Set-State.", "tags": ["micronaut", "lifecycle", "sco1"]}
{"instruction": "Describe the Micronaut chat.txt @record v1 format.", "input": "", "output": "chat.txt @record v1 format (append-only):\n\n@record v1\ntype    = MESSAGE\nfrom    = <actor sigil + name>\ntime    = <ISO-8601 UTC>\npayload = <text body>\ncm1     = <PASS | FAIL | ILLEGAL>\n@@\n\nExample:\n@record v1\ntype    = MESSAGE\nfrom    = #user\ntime    = 2025-11-15T14:30:00Z\npayload = What is the current threat level?\ncm1     = PASS\n@@\n\nRules:\n  - Each record is delimited by @record v1 ... @@\n  - cm1 field must be present; FAIL/ILLEGAL records are logged but not processed\n  - Only PASS records enter the KUHUL-TSG extraction pipeline\n  - File is append-only; no deletion or mutation", "tags": ["micronaut", "chat", "format"]}
{"instruction": "Describe the Micronaut stream.txt output format.", "input": "", "output": "stream.txt output format (append-only, replayable):\n\nEach emission is a chunk prefixed with >>:\n\n>> TIMESTAMP | DOMAIN | SIGNAL\n\nExample emissions:\n>> 2025-11-15T14:30:01Z | inference | intent=threat_query confidence=0.94\n>> 2025-11-15T14:30:01Z | projection | hud.warn:threat-level-high\n>> 2025-11-15T14:30:02Z | trace | scxq2.lane:04A10100000001000304XXXX\n\nEnd-of-sequence marker:\n>> EOS\n\nRules:\n  - Each >> line is one semantic emission\n  - Chunks are replayable: replaying stream.txt reproduces the session\n  - EOS marks the end of a response sequence\n  - No mutation of prior lines", "tags": ["micronaut", "stream", "format"]}
{"instruction": "Write a PowerShell snippet that implements CM-1 verification for chat.txt records.", "input": "", "output": "function Invoke-CM1Verify {\n    param([string]$Text)\n    # CM-1: control character DFA — PASS if no illegal chars\n    foreach ($ch in $Text.ToCharArray()) {\n        $code = [int]$ch\n        if ($code -lt 0x20 -and $code -ne 0x0A -and $code -ne 0x0D -and $code -ne 0x09) {\n            if ($code -eq 0x00) { return 'ILLEGAL' }  # null byte\n            return 'FAIL'  # other control chars\n        }\n    }\n    return 'PASS'\n}\n\n# Usage:\n$result = Invoke-CM1Verify -Text $record.payload\nif ($result -ne 'PASS') {\n    Add-Content $traceFile \"CM1:$result:$($record.from):$(Get-Date -Format o)\"\n    return  # do not process\n}", "tags": ["micronaut", "cm1", "powershell"]}
{"instruction": "Write a PowerShell snippet that extracts KUHUL-TSG signal from a chat.txt message.", "input": "", "output": "function Invoke-KUHUL-TSG {\n    param([string]$Payload)\n    $tokens = $Payload -split '\\s+' | Where-Object { $_ -ne '' }\n    $signal = @{\n        tokens    = $tokens\n        count     = $tokens.Count\n        timestamp = (Get-Date -Format 'o')\n        intent    = ($tokens | Select-Object -First 3) -join '_'\n        payload   = $Payload\n    }\n    return $signal\n}\n\n# Usage in orchestrator main loop:\n$signal = Invoke-KUHUL-TSG -Payload $record.payload\n$mass   = $signal.count * 0.1\nAdd-Content $streamFile \">> $($signal.timestamp) | inference | intent=$($signal.intent) mass=$mass\"", "tags": ["micronaut", "kuhul-tsg", "powershell"]}
{"instruction": "Write a PowerShell snippet for the Micronaut orchestrator main loop.", "input": "", "output": "$state = 'INIT'\n$chatFile   = Join-Path $PSScriptRoot 'io/chat.txt'\n$streamFile = Join-Path $PSScriptRoot 'io/stream.txt'\n$lastLine   = 0\n\nSet-State 'READY'\n\nwhile ($state -ne 'HALT') {\n    $lines = Get-Content $chatFile -ErrorAction SilentlyContinue\n    if ($lines.Count -gt $lastLine) {\n        Set-State 'RUNNING'\n        $newLines = $lines[$lastLine..($lines.Count - 1)]\n        $lastLine = $lines.Count\n\n        foreach ($block in (Parse-Records $newLines)) {\n            $cm1 = Invoke-CM1Verify -Text $block.payload\n            if ($cm1 -ne 'PASS') { continue }\n            $signal = Invoke-KUHUL-TSG -Payload $block.payload\n            $result = Invoke-SCXQ2-Infer -Signal $signal\n            Add-Content $streamFile \">> $($signal.timestamp) | inference | $result\"\n        }\n        Add-Content $streamFile '>> EOS'\n    } else {\n        Set-State 'IDLE'\n    }\n    Start-Sleep -Seconds 1\n}", "tags": ["micronaut", "orchestrator", "powershell"]}
{"instruction": "Describe the Micronaut REST loopback file mapping.", "input": "", "output": "Micronaut REST Loopback (file router, no execution authority):\n\n  Endpoint         Method   File                Action\n  /chat            POST     io/chat.txt         Append @record\n  /stream          GET      io/stream.txt       Read all lines\n  /stream/last     GET      io/stream.txt       Read last N lines\n  /state           GET      io/snapshot/        Read latest snapshot\n  /health          GET      (computed)          Return lifecycle state\n\nRules:\n  - POST /chat only appends; never overwrites or deletes\n  - GET endpoints are read-only\n  - No endpoint executes code or triggers inference directly\n  - The orchestrator polls chat.txt independently of REST\n  - All endpoints are localhost-only (127.0.0.1)", "tags": ["micronaut", "rest", "loopback"]}
{"instruction": "Show how the Micronaut orchestrator saves a state snapshot.", "input": "", "output": "function Save-Snapshot {\n    param([hashtable]$State)\n    $snapDir = Join-Path $PSScriptRoot 'io/snapshot'\n    if (-not (Test-Path $snapDir)) { New-Item -ItemType Directory -Path $snapDir | Out-Null }\n\n    $timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'\n    $snapFile  = Join-Path $snapDir \"snap_$timestamp.json\"\n    $State | ConvertTo-Json -Depth 10 | Set-Content $snapFile\n\n    # Rotate: keep only last 10 snapshots\n    $snaps = Get-ChildItem $snapDir -Filter 'snap_*.json' | Sort-Object Name\n    if ($snaps.Count -gt 10) {\n        $snaps[0..($snaps.Count - 11)] | Remove-Item\n    }\n}\n\n# Called after each inference cycle:\nSave-Snapshot @{ state=$state; lastLine=$lastLine; time=(Get-Date -Format 'o') }", "tags": ["micronaut", "snapshot", "powershell"]}
{"instruction": "Explain the Micronaut object.toml structure.", "input": "", "output": "object.toml declares the Micronaut SCO/1 sealed object:\n\n[seal]\n  type     = \"SCO/1\"          # Sovereign Computational Object v1\n  kernel   = \"SCXQ7\"          # Immutable execution kernel\n  hash_alg = \"blake3-256\"     # Hash algorithm for integrity\n\n[capabilities]\n  read     = true             # Can read brains, io/\n  write    = [\"io/\"]          # Can only write to io/ directory\n  execute  = false            # No code execution authority\n  network  = false            # No outbound network access\n\n[io.chat_format]\n  type     = \"append-only\"\n  record   = \"@record v1\"     # CM-1 verified MESSAGE records\n\n[io.stream_format]\n  type     = \"append-only\"\n  prefix   = \">>\"             # Each emission line prefix\n  eos      = \">> EOS\"         # End-of-sequence marker\n\n[lifecycle]\n  states      = [\"INIT\",\"READY\",\"RUNNING\",\"IDLE\",\"HALT\"]\n  transitions = {INIT=\"READY\", READY=\"RUNNING\", RUNNING=[\"IDLE\",\"HALT\"], IDLE=[\"RUNNING\",\"HALT\"]}", "tags": ["micronaut", "toml", "sco1"]}
{"instruction": "Write CM-1 test vectors for chat.txt verification.", "input": "", "output": "CM-1 Test Vectors:\n\nVector 1 — PASS (clean ASCII text):\n  Input:  \"Hello, what is the status?\"\n  Result: PASS\n\nVector 2 — PASS (with allowed whitespace):\n  Input:  \"Line one\\nLine two\\tTabbed\"\n  Result: PASS  (0x0A, 0x0D, 0x09 are allowed)\n\nVector 3 — FAIL (control character 0x07 BEL):\n  Input:  \"Hello\\x07World\"\n  Result: FAIL\n\nVector 4 — ILLEGAL (null byte 0x00):\n  Input:  \"Hello\\x00World\"\n  Result: ILLEGAL\n\nVector 5 — FAIL (escape 0x1B):\n  Input:  \"\\x1B[31mRed\\x1B[0m\"\n  Result: FAIL  (ANSI escape sequences rejected)", "tags": ["cm1", "test-vectors", "verification"]}
{"instruction": "Describe the Ramble Engine and its constraints.", "input": "", "output": "The Ramble Engine is any LLM model that extrapolates collapse results into narrative.\n\nAuthority: None — it explains what is already decided, never decides.\n\nInputs:\n  - stream.txt emissions (post-inference)\n  - Snapshot state\n  - Operator query\n\nOutputs:\n  - Natural language explanation of what happened\n  - Narrative summary of state transitions\n  - Trend analysis of historical snapshots\n\nConstraints:\n  - No feedback into π — output never re-enters the collapse pipeline\n  - No state mutation — Ramble Engine is read-only\n  - No authority — it cannot trigger actions, emit lanes, or modify stream.txt\n  - Determinism not required — narrative may vary across runs\n\nTruth collapses once. Explanation may unfold forever.", "tags": ["ramble-engine", "reference", "architecture"]}
{"instruction": "Explain the relationship between Micronaut orchestration and KUHUL π enforcement.", "input": "", "output": "Micronaut and KUHUL π are orthogonal systems:\n\n  Micronaut (Orchestration):\n    - Routes files, manages lifecycle\n    - PowerShell-based, no reasoning\n    - Reads brains, writes io/\n    - Never enforces law\n    - Building blocks: 80+ types across 12 domains\n\n  KUHUL π (Law Enforcement):\n    - Defines what is legal\n    - Signs tokenizer configs, lane streams\n    - Verifies CM-1, validates domain integrity\n    - Authority source for all π-signed artifacts\n    - Immutable: law does not change at runtime\n\nThey do NOT overlap:\n  - Micronaut never calls π\n  - π never routes files\n  - Micronaut orchestrates; π enforces\n  - Both are needed; neither replaces the other", "tags": ["micronaut", "kuhul-pi", "architecture"]}
{"instruction": "Describe the SCX tokenizer encoding pipeline.", "input": "", "output": "SCX-TOK-V1 Encoding Pipeline:\n\n1. Binary substrate alignment:\n   - Split input into K-byte chunks (e.g., 4 KiB)\n   - Regroup bytes into bundles per lane packing law\n   - Pad incomplete bundles with PAD-BYTE\n\n2. Lane packing:\n   - Group bytes into lanes of width W (SCXQ2: W=2, SCXQ4: W=4)\n   - Group lanes into bundles of size N (e.g., 8 lanes)\n   - Wrap each bundle: BUNDLE_START | lanes | BUNDLE_END\n\n3. Registry merges:\n   - Map lane byte patterns to token IDs via SCX-TOK-REG-V1\n   - Raw lanes → raw lane tokens\n   - Known patterns → composite lane tokens\n\n4. Control token insertion:\n   - SHARD_START / SHARD_END at shard boundaries\n   - BUNDLE_PAD for padded bundles\n   - Error sentinels for invalid patterns\n\nResult: T = f_SCX-TOK-V1(B, R, L)\nDeterministic: identical (B, R, L, version) → bit-identical tokens.", "tags": ["scx-tokenizer", "encoding", "reference"]}
{"instruction": "Describe the SCX tokenizer token space reserved ranges.", "input": "", "output": "SCX-TOK-V1 Token Space (u16, 0–65535):\n\n  Range           Purpose\n  0x0000–0x00FF   Raw bytes (BYTE_0x00 … BYTE_0xFF)\n  0x0100–0x01FF   Lane control tokens (per lane packing law)\n  0x0200–0x02FF   Substrate markers (shard boundaries, bundle markers)\n  0x0300–0x03FF   AGL/π control (authority, manifest, error sentinels)\n  0x0400+         Registry-assigned composites (multi-byte patterns, opcodes, glyphs)\n\nKey control tokens:\n  0x0100  BUNDLE_START\n  0x0101  BUNDLE_END\n  0x0102  BUNDLE_PAD\n  0x0103  PAD_LANE\n  0x0200  SHARD_START\n  0x0201  SHARD_END\n  0x0300  PI_AUTHORITY\n  0x0301  MANIFEST_REF\n  0x0302  ERROR_SENTINEL", "tags": ["scx-tokenizer", "reference", "encoding"]}
{"instruction": "Describe the SCX execution model architecture layers.", "input": "", "output": "SCX Execution Model (top to bottom):\n\n  Layer 1: SCX Control Law (semantic layer)\n    Defines what reality is. Domains: geometry, graph, tensor, agent, UI.\n\n  Layer 2: SCXQ2/Q4 Lane Stream (transport layer)\n    Carries SCX instructions as compact execution packets.\n    One lane = one causal mutation.\n\n  Layer 3: Lane Interpreter (causality engine)\n    Decodes lanes, routes to domains, applies deterministic mutation.\n\n  Layer 4: Domain Engines\n    Geometry (spatial state), Graph (relationships), Tensor (multidimensional),\n    Agent (autonomous behavior), UI (projection of state).\n\n  Layer 5: Snapshot & Replay\n    State(T) = Snapshot + Lanes. Enables rewind, branching, audit.\n\nData flow: SCX instructions → Lane packing → Transport → Interpreter →\n  Domain mutation → Agent + UI reaction → Snapshot recorded.", "tags": ["scx", "architecture", "execution-model"]}
{"instruction": "Write SCX for connecting the chat UI to a remote API endpoint.", "input": "Target: https://api.example.com/v1/chat", "output": "@connector (>) \"register:http:https://api.example.com/v1/chat\"\n@http_adapter (>) \"open:https://api.example.com/v1/chat\"\n!chat-ui (>) \"bind:connector:1\"\n#user (>) @connector \"send:{ message:'Hello from SCX' }\"\n@connector (>) !chat-ui \"receive:{ reply:'Response from API' }\"\n%db.logs (+) { event:\"connector_bind\", target:\"api.example.com\", mode:\"chat\", time:*now }", "tags": ["scx", "connector", "chat", "http"]}
{"instruction": "Write SCX for connecting the studio UI to a local folder for file browsing.", "input": "Target: /home/user/project", "output": "@connector (>) \"register:file:///home/user/project\"\n@fs_adapter (>) \"open:/home/user/project\"\n!studio-ui (>) \"bind:connector:2\"\n!studio-ui (>) \"panel:file-browser:/home/user/project\"\n@fs_adapter (>) !studio-ui \"listing:{ files:['src/','README.md','package.json'] }\"\n%local.state (∂) studio_target = \"/home/user/project\"", "tags": ["scx", "connector", "studio", "filesystem"]}
{"instruction": "Write SCX for connecting via WebSocket to a live data stream.", "input": "Target: wss://stream.example.com/feed", "output": "@connector (>) \"register:ws:wss://stream.example.com/feed\"\n@ws_adapter (>) \"open:wss://stream.example.com/feed\"\n!chat-ui (>) \"bind:connector:3\"\n@ws_adapter (>) \"subscribe:channel:live\"\n@ws_adapter (>) !chat-ui \"data:{ tick:1, price:42.50 }\"\n@ws_adapter (>) !chat-ui \"data:{ tick:2, price:42.75 }\"\n%db.logs (+) { event:\"ws_subscribe\", channel:\"live\", time:*now }", "tags": ["scx", "connector", "websocket", "streaming"]}
{"instruction": "Write SCX for IPC communication between Micronaut and a local Python service.", "input": "Target: ipc:///tmp/ml-service.sock", "output": "@connector (>) \"register:ipc:ipc:///tmp/ml-service.sock\"\n@ipc_adapter (>) \"open:/tmp/ml-service.sock\"\n^mx2qwen (>) @ipc_adapter \"send:{ action:'predict', input:[0.5,0.3,0.8] }\"\n@ipc_adapter (>) ^mx2qwen \"receive:{ prediction:0.92, label:'threat' }\"\n!hud (>) \"warn:threat-detected:0.92\"\n%db.logs (+) { event:\"ipc_predict\", service:\"ml-service\", confidence:0.92, time:*now }", "tags": ["scx", "connector", "ipc", "ai"]}
{"instruction": "Describe the universal connector protocol auto-detection.", "input": "", "output": "Universal connector auto-detects protocol from URI scheme:\n\n  URI Scheme       Protocol      Adapter\n  http://          HTTP          HttpAdapter (fetch-based, polling)\n  https://         HTTP          HttpAdapter (fetch-based, polling)\n  ws://            WebSocket     WsAdapter (duplex, message queue)\n  wss://           WebSocket     WsAdapter (duplex, message queue)\n  file://          Filesystem    FsAdapter (sandboxed, safePath)\n  ipc://           IPC           IpcAdapter (message channel)\n  /path/to/dir     Filesystem    FsAdapter (bare path → file://)\n\nConnection flow:\n  1. Register target (registry or ad-hoc URI)\n  2. resolveProtocol(uri) → adapter class\n  3. adapter.open() → connection established\n  4. UI binds to connector for bidirectional data flow\n  5. Status projected via WebSocket to UI panels", "tags": ["connector", "reference", "protocol"]}
{"instruction": "Explain the Micronaut sealed brain file structure for a domain.", "input": "Domain: debug", "output": "Each Micronaut domain has three sealed brain files:\n\n1. trigrams.json — 3-word context patterns with confidence scores:\n   {\n     \"sealed\": true,\n     \"domain\": \"debug\",\n     \"entries\": {\n       \"breakpoint watch evaluate\": 0.94,\n       \"step over continue\": 0.91,\n       \"stack frame inspect\": 0.89\n     }\n   }\n\n2. bigrams.json — 2-word context pairs with confidence scores:\n   {\n     \"sealed\": true,\n     \"domain\": \"debug\",\n     \"entries\": {\n       \"debug context\": 0.95,\n       \"breakpoint watch\": 0.88,\n       \"stack frame\": 0.87\n     }\n   }\n\n3. intents.json — intent-to-target mapping with verbs:\n   {\n     \"sealed\": true,\n     \"domain\": \"debug\",\n     \"entries\": {\n       \"debug\": {\"targets\": [\"DebugMicronaut\"], \"confidence\": 0.95, \"verbs\": [\"breakpoint\",\"watch\",\"step\",\"evaluate\"]}\n     }\n   }\n\nBrains are read-only. Never mutated at runtime.", "tags": ["micronaut", "brains", "ngrams", "sealed"]}
{"instruction": "Show SCX for an AI agent performing bigram→trigram→intent brain query routing.", "input": "Agent: ^mx2qwen, Domain: game, Query: 'enemy spotted'", "output": "^mx2qwen (>) brains.game.bigrams \"enemy spotted\"\n  → result: { match:\"enemy spotted\", action:\"seek cover\", confidence:0.95 }\n^mx2qwen (>) brains.game.trigrams \"enemy spotted quickly\"\n  → result: { match:\"enemy spotted quickly\", action:\"evade and flank\", confidence:0.93 }\n^mx2qwen (>) brains.game.intents \"combat\"\n  → result: { targets:[\"CombatMicronaut\"], verbs:[\"attack\",\"defend\",\"evade\",\"patrol\"], confidence:0.96 }\n^CombatMicronaut (>) \"evade\" { context:\"enemy spotted\", zone:\"sector_3\" }", "tags": ["brains", "ngrams", "agents", "game", "micronaut"]}
{"instruction": "Describe the 12 Micronaut registry domains and their purposes.", "input": "", "output": "Micronaut Registry v1.0 — 12 domains, 80+ types:\n\n  Domain       Purpose                    Example Types\n  core         Foundation building blocks  BaseMicronaut, MemoryMicronaut, SchedulerMicronaut\n  application  App lifecycle & config      AppMicronaut, ConfigMicronaut, PluginMicronaut\n  ui           Interface & layout          LayoutMicronaut, ThemeMicronaut, AnimationMicronaut\n  game         Game logic & physics        PhysicsMicronaut, CombatMicronaut, InventoryMicronaut\n  rendering    Visual output pipeline      MeshMicronaut, ShaderMicronaut, CameraMicronaut\n  data         Storage & streaming         DatabaseMicronaut, CacheMicronaut, StreamMicronaut\n  ai           Intelligence & learning     InferenceMicronaut, TrainerMicronaut, PlannerMicronaut\n  system       OS & process management     ProcessMicronaut, FileMicronaut, RegistryMicronaut\n  network      Connectivity & protocols    HttpMicronaut, SocketMicronaut, ProtocolMicronaut\n  storage      Persistence & backup        DiskMicronaut, SnapshotMicronaut, ArchiveMicronaut\n  debug        Diagnostics & profiling     DebugMicronaut, LogMicronaut, ProfilerMicronaut", "tags": ["micronaut", "registry", "reference"]}
{"instruction": "Write SCX for a complete Micronaut inference cycle: receive input, verify, extract, infer, emit.", "input": "Message: 'What is the threat level in sector 9?'", "output": "@rest (>) io/chat.txt (+) \"@record v1\\ntype=MESSAGE\\nfrom=#user\\ntime=2025-11-15T14:30:00Z\\npayload=What is the threat level in sector 9?\\ncm1=PASS\\n@@\"\n^orchestrator (>) cm1.verify \"What is the threat level in sector 9?\" → PASS\n^orchestrator (>) kuhul-tsg.extract → { tokens:[\"What\",\"is\",\"the\",\"threat\",\"level\",\"in\",\"sector\",\"9\"], intent:\"What_is_the\" }\n^orchestrator (>) scxq2.infer → { signal:\"threat_query\", mass:0.8, confidence:0.94 }\n^orchestrator (>) io/stream.txt (+) \">> 2025-11-15T14:30:01Z | inference | intent=threat_query confidence=0.94\"\n^orchestrator (>) io/stream.txt (+) \">> EOS\"", "tags": ["micronaut", "inference", "pipeline", "scx"]}
{"instruction": "Write SCX sigil lines for a multiplayer trading session between two players.", "input": "", "output": "#player_a (>) @trade \"offer:item:plasma-rifle:price:200\"\n#player_b (>) @trade \"accept:offer:player_a:plasma-rifle\"\n$wallet_b (>) \"spend:200\"\n$wallet_a (>) \"receive:200\"\n#player_a (>) $inventory \"remove:plasma-rifle\"\n#player_b (>) $inventory \"add:plasma-rifle\"\n%db.trades (+) { seller:\"#player_a\", buyer:\"#player_b\", item:\"plasma-rifle\", price:200, time:*now }\n!ui (>) \"notify:trade-complete\"", "tags": ["scx", "commerce", "multiplayer"]}
{"instruction": "Write SCX for zone-based event propagation: event occurs in zone, all entities react.", "input": "Zone: &reactor_core, Event: meltdown_warning", "output": "&reactor_core (>) \"broadcast:meltdown_warning\"\n#guard_01 (>) ^janus \"evacuate:reactor_core\"\n#guard_02 (>) ^janus \"evacuate:reactor_core\"\n#scientist (>) ^mx2cline \"emergency:shutdown-protocol\"\n&reactor_core (∂) state = \"critical\"\n!hud (>) \"alert:MELTDOWN WARNING - EVACUATE\"\n%db.events (+) { type:\"meltdown_warning\", zone:\"reactor_core\", entities:[\"guard_01\",\"guard_02\",\"scientist\"], time:*now }", "tags": ["scx", "zones", "events", "actions"]}
{"instruction": "Write SCX for a permission-gated action: check authority before executing.", "input": "Actor: #admin, Action: delete user, Target: %db.users", "output": "@auth (>) \"check:permission:#admin:delete:users\"\n@auth (>) #admin \"grant:delete:users\"\n%db.users (∂) { action:\"delete\", id:\"u_target\", by:\"#admin\" }\n%db.audit (+) { event:\"user_delete\", target:\"u_target\", actor:\"#admin\", authorized:true, time:*now }\n!admin-panel (>) \"notify:user-deleted:u_target\"", "tags": ["scx", "auth", "permissions"]}
{"instruction": "Write SCX for a scheduled task: agent wakes at interval, performs action, sleeps.", "input": "Agent: ^scheduler, Interval: 60s, Task: health-check", "output": "^scheduler (>) @timer \"set:interval:60s:health-check\"\n@timer (>) ^scheduler \"tick:health-check\"\n^scheduler (>) @http \"GET:http://localhost:3000/health\"\n@http (>) ^scheduler \"response:{ status:200, state:'RUNNING' }\"\n%db.health (+) { check:\"health\", status:200, state:\"RUNNING\", time:*now }\n^scheduler (>) \"sleep:until:next-tick\"", "tags": ["scx", "scheduling", "agents"]}
{"instruction": "Show SCXQ2 lane stream transport over network with compression.", "input": "", "output": "SCXQ2 Network Transport:\n\n1. Pack lanes into SCXQ2 container:\n   Header: SCX2 | v1 | flags=0x02 (ZSTD) | dict=5 | lanes=100 | meta=offset\n\n2. Compress lane stream with ZSTD:\n   Raw stream (e.g., 2400 bytes) → compressed (e.g., 800 bytes)\n\n3. Transmit over WebSocket:\n   @ws (>) \"send:binary:scxq2_packet_compressed\"\n\n4. Receiver decompresses:\n   Verify magic=\"SCX2\", version=0x01\n   Decompress via ZSTD\n   Load dictionary\n   Process lanes sequentially\n\n5. Replay verification:\n   streamHash = HASH(all lane bytes)\n   Verify against sender's signed hash\n\nNo full file needed in memory — lanes stream sequentially.", "tags": ["scxq2", "transport", "network", "compression"]}
{"instruction": "Write SCX for SCXQ2 lane stream recording and replay.", "input": "", "output": "Recording:\n  ^interpreter (>) @recorder \"start:session:s_001\"\n  # ... lanes execute and get recorded ...\n  ^interpreter (>) @recorder \"stop:session:s_001\"\n  @recorder (>) %db.sessions (+) {\n    id:\"s_001\",\n    lane_count:42,\n    stream_hash:\"blake3:abc123...\",\n    snapshot_at_start:\"snap_20251115_143000.json\",\n    time:*now\n  }\n\nReplay:\n  ^interpreter (>) @replayer \"load:session:s_001\"\n  @replayer (>) \"restore:snapshot:snap_20251115_143000.json\"\n  @replayer (>) \"stream:lanes:s_001\"  # feeds lanes to interpreter\n  # State rebuilds deterministically from snapshot + lanes\n\nInvariant: replay(snapshot + lanes) = original state", "tags": ["scxq2", "replay", "snapshot", "determinism"]}
{"instruction": "Explain SCXQ4 shard and stream rules.", "input": "", "output": "SCXQ4 Shard & Stream Rules:\n\n1. Streams are concatenations of lanes:\n   Lane1 | Lane2 | Lane3 | ... (no padding between lanes)\n\n2. Shards are subsets of streams:\n   - Shard boundaries must align between lanes (never split a lane)\n   - Each shard is independently decodable with its dictionary\n\n3. Compression wrappers (GZIP/ZSTD/SCX entropy):\n   - Must preserve lane boundaries\n   - Compressed shards decompress to complete lanes\n\n4. Shard signing:\n   streamHash = HASH(all lane bytes in shard)\n   signature  = SIGN(streamHash, authorityKey)\n\n5. Multi-shard streams:\n   - Each shard has its own hash and signature\n   - Shards can be transmitted/stored independently\n   - Replay assembles shards in order\n\nLane atomicity: a lane is never split across shards.", "tags": ["scxq4", "shards", "streaming", "reference"]}
{"instruction": "Write SCXQ4 lanes for a large tensor update across multiple dimensions.", "input": "%model.weights[layer:3][neuron:128][weight:64] (∂) = 0.7531", "output": "SCXQ4 Lane:\n  Domain:     0x03 (Tensor/Field)\n  Opcode:     0x00A2 (Mutate)\n  Flags:      0x04 (Persistent)\n  TargetID:   0x0000_0001_00000003 (cluster 0, domain 1, model #3)\n  PayloadLen: 0x0000000F (15 bytes)\n  Payload:\n    0x06          (TensorIndex type)\n    0x03          (3 dimensions)\n    [u16(3)]      (layer index)\n    [u16(128)]    (neuron index)\n    [u16(64)]     (weight index)\n    0x01          (Scalar float follows)\n    [float32(0.7531)]  (0x3F40D70A)\n\nSCXQ4 enables this because:\n  - 64-bit TargetID addresses model across clusters\n  - 4GB payload capacity supports batch weight updates\n  - Same semantics as SCXQ2 but wider addressing", "tags": ["scxq4", "lanes", "tensor", "ai"]}
{"instruction": "Show the complete SCXQ2 lane record format with byte layout.", "input": "", "output": "SCXQ2 Lane Record:\n\n  Byte Offset  Field       Size    Description\n  0            Domain      1B      Domain ID (0x01-0x05)\n  1            Op          1B      Operator code (0xA1-0xA4)\n  2            Flags       1B      Scope flags (bitfield)\n  3-6          TargetID    4B      Entity/node/tensor/agent ID (u32 BE)\n  7-8          PayloadLen  2B      Payload byte count (u16 BE)\n  9+           Payload     var     Encoded symbolic payload\n\nMinimum lane size: 9 bytes (header) + 0 bytes (empty payload)\nMaximum payload: 65,535 bytes (u16 limit)\n\nLanes are packed sequentially with no padding:\n  [Lane1_header][Lane1_payload][Lane2_header][Lane2_payload]...\n\nAll integers are big-endian. Floats are IEEE-754.", "tags": ["scxq2", "binary", "format", "reference"]}
{"instruction": "Write a complete ASX page with multiple blocks, atomic CSS, and SCX event bindings.", "input": "", "output": "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    .text-sm{font-size:.85rem}.text-md{font-size:1rem}.text-lg{font-size:1.35rem}\n    .pad-sm{padding:6px}.pad-md{padding:12px}.pad-lg{padding:24px}\n    .flex{display:flex}.row{flex-direction:row}.col{flex-direction:column}\n    .gap-sm{gap:6px}.gap-md{gap:12px}.gap-lg{gap:20px}\n    .bg-dark{background:#0b0e12;color:#E6F1FF}\n    .bg-panel{background:#11161c;border-radius:10px}\n    .text-accent{color:#7cd3ff}\n    .border{border:1px solid #23303d;border-radius:8px}\n    .grid{display:grid}.grid-2{grid-template-columns:repeat(2,1fr)}\n  </style>\n  <script src=\"asx-runtime.js\" defer></script>\n</head>\n<body class=\"bg-dark pad-lg\">\n  <asx-block id=\"nav-bar\">\n    <div class=\"flex row gap-md bg-panel pad-md\">\n      <button class=\"border\" scx=\"!ui (>) 'open:inventory'\">Inventory</button>\n      <button class=\"border\" scx=\"!ui (>) 'open:map'\">Map</button>\n      <button class=\"border\" scx=\"#player (>) ^janus 'scan:area'\">Scan</button>\n    </div>\n  </asx-block>\n  <div class=\"grid grid-2 gap-md pad-md\">\n    <asx-block id=\"status-bar\">\n      <div class=\"bg-panel pad-md\">\n        <span class=\"text-accent\" bind=\"player.health\">HP: --</span>\n        <span class=\"text-accent\" bind=\"player.caps\">CAPS: --</span>\n      </div>\n    </asx-block>\n    <asx-block id=\"chat-log\">\n      <div class=\"bg-panel pad-md col gap-sm\" style=\"max-height:300px;overflow-y:auto\">\n        <div class=\"text-sm\" each=\"msg in chat.messages\">\n          <span class=\"text-accent\" bind=\"msg.agent\"></span>: <span bind=\"msg.text\"></span>\n        </div>\n      </div>\n    </asx-block>\n  </div>\n</body>\n</html>", "tags": ["asx-block", "asxr", "css", "ui", "html", "scx"]}
{"instruction": "Write SCX for a data pipeline: ingest CSV, transform, store, and notify.", "input": "Source: /data/sales.csv", "output": "@fs (>) \"read:/data/sales.csv\"\n@transform (>) \"parse:csv:sales.csv\" → { rows:150, columns:[\"date\",\"item\",\"amount\"] }\n@transform (>) \"aggregate:sum:amount:by:item\"\n%db.analytics (+) { report:\"sales_summary\", rows:150, aggregated:true, time:*now }\n@fs (>) \"write:/output/sales_summary.json\"\n!dashboard (>) \"refresh:sales-chart\"\n%db.logs (+) { event:\"pipeline_complete\", source:\"sales.csv\", time:*now }", "tags": ["scx", "data", "pipeline", "actions"]}
{"instruction": "Write SCX for an AI training loop: load data, train batch, checkpoint, report.", "input": "", "output": "^trainer (>) @fs \"read:/models/config.toml\"\n^trainer (>) %db.datasets \"query:training-set:batch-001\"\n^trainer (>) \"train:batch:001\" → { loss:0.042, accuracy:0.97, steps:1000 }\n^trainer (>) @fs \"write:/checkpoints/model_v3_step1000.bin\"\n%db.training (+) { model:\"v3\", step:1000, loss:0.042, accuracy:0.97, time:*now }\n!dashboard (>) \"update:training-progress:step-1000\"\n^trainer (>) \"next:batch:002\"", "tags": ["scx", "ai", "training", "actions"]}
{"instruction": "Write SCX for connecting the chat UI to multiple targets simultaneously.", "input": "Targets: API endpoint, local folder, WebSocket stream", "output": "@connector (>) \"register:http:https://api.example.com/v1/chat\"\n@connector (>) \"register:file:///home/user/docs\"\n@connector (>) \"register:ws:wss://stream.example.com/feed\"\n!chat-ui (>) \"bind:connector:1\"  # API\n!chat-ui (>) \"bind:connector:2\"  # folder\n!chat-ui (>) \"bind:connector:3\"  # stream\n!chat-ui (>) \"mode:multi-source\"\n%local.state (∂) active_connectors = [1,2,3]\n%db.logs (+) { event:\"multi_connect\", targets:3, mode:\"chat\", time:*now }", "tags": ["scx", "connector", "chat", "multi-target"]}
{"instruction": "Write SCX for the studio UI opening multiple panels with different data sources.", "input": "", "output": "!studio-ui (>) \"layout:grid-3\"\n!studio-ui (>) \"panel:open:file-browser\" { source:\"file:///home/user/project\", position:\"left\" }\n!studio-ui (>) \"panel:open:api-explorer\" { source:\"https://api.example.com/v1\", position:\"center\" }\n!studio-ui (>) \"panel:open:live-stream\" { source:\"wss://stream.example.com/feed\", position:\"right\" }\n!studio-ui (>) \"panel:open:command-palette\" { position:\"bottom\" }\n%local.state (∂) studio_layout = \"grid-3\"\n%local.state (∂) studio_panels = [\"file-browser\",\"api-explorer\",\"live-stream\",\"command-palette\"]", "tags": ["scx", "studio", "connector", "panels"]}
{"instruction": "Write a SCXQ2 dictionary block for a game session with combat and trade tokens.", "input": "", "output": "SCXQ2 Dictionary Block:\n\n  TokenID | Len | Value\n  0x0401  | 06  | \"attack\"\n  0x0402  | 06  | \"defend\"\n  0x0403  | 05  | \"evade\"\n  0x0404  | 06  | \"patrol\"\n  0x0405  | 04  | \"scan\"\n  0x0406  | 05  | \"trade\"\n  0x0407  | 06  | \"barter\"\n  0x0408  | 04  | \"loot\"\n  0x0409  | 05  | \"craft\"\n  0x040A  | 08  | \"position\"\n  0x040B  | 08  | \"velocity\"\n  0x040C  | 06  | \"health\"\n  0x040D  | 14  | \"open:inventory\"\n  0x040E  | 08  | \"open:map\"\n\nAll entries use registry-assigned composite range (0x0400+).\nTokenIDs are referenced by lanes via 0x04 payload type.", "tags": ["scxq2", "dictionary", "binary", "game"]}
{"instruction": "Describe how SCX runtime guarantees are achieved.", "input": "", "output": "SCX Runtime Guarantees and How They're Achieved:\n\n1. Determinism:\n   - Lane interpretation is a pure function of (state, lane)\n   - No random, no clock-dependent branching\n   - Tokenizer is deterministic: T = f(B, R, L)\n\n2. Replayability:\n   - State(T) = Snapshot + ordered Lanes\n   - stream.txt is append-only and replayable\n   - Snapshot + lane replay = identical final state\n\n3. Cross-runtime portability:\n   - Binary format is fully specified (endianness, sizes, types)\n   - Domain IDs and operators are universal constants\n   - No runtime-specific extensions in lane format\n\n4. Domain isolation:\n   - Each domain engine operates independently\n   - Lanes route to exactly one domain\n   - Cross-domain effects only via new lanes\n\n5. Causality auditability:\n   - Every mutation is a lane with timestamp\n   - Lane streams form a causal log\n   - Any state can be explained by its lane history", "tags": ["scx", "architecture", "guarantees", "reference"]}
{"instruction": "Write SCX for a K'uhul glyph encoding round-trip: text to glyphs and back.", "input": "Text: 'entity.move(12,4,0)'", "output": "@cipher (>) \"encode:kuhul:entity.move(12,4,0)\"\n@cipher (>) #app \"glyph:⟁entity⟁move⟁12⟁4⟁0⟁\"\n@cipher (>) \"decode:kuhul:⟁entity⟁move⟁12⟁4⟁0⟁\"\n@cipher (>) #app \"text:entity.move(12,4,0)\"\n%db.logs (+) { event:\"glyph_roundtrip\", input:\"entity.move(12,4,0)\", verified:true, time:*now }\n\nK'uhul encoding uses ⟁ as delimiter.\nRound-trip: encode(text) → glyphs → decode(glyphs) = original text.", "tags": ["scx", "kuhul", "cipher", "encoding"]}
{"instruction": "Define SCX for a wallet staking and reward distribution flow.", "input": "", "output": "#user (>) $wallet \"stake:500:pool:alpha\"\n@staking (>) %db.pools (∂) { pool:\"alpha\", staked:+500, staker:\"#user\" }\n@staking (>) \"calculate:rewards:pool:alpha:epoch:42\"\n@staking (>) $wallet \"reward:25:pool:alpha:epoch:42\"\n%db.rewards (+) { pool:\"alpha\", epoch:42, reward:25, to:\"#user\", time:*now }\n!wallet-ui (>) \"update:balance:#user\"", "tags": ["scx", "commerce", "staking", "wallet"]}
{"instruction": "Write SCX for a multi-agent collaborative task: planner assigns, workers execute, aggregator collects.", "input": "", "output": "^planner (>) \"decompose:task:build-report\" → [\"gather-data\",\"analyze\",\"format\"]\n^planner (>) ^worker_1 \"assign:gather-data\"\n^planner (>) ^worker_2 \"assign:analyze\"\n^worker_1 (>) @fs \"read:/data/metrics.csv\" → { rows:500 }\n^worker_1 (>) ^aggregator \"deliver:gather-data:{ rows:500 }\"\n^worker_2 (>) \"analyze:metrics\" → { trends:[\"up\",\"stable\",\"down\"] }\n^worker_2 (>) ^aggregator \"deliver:analyze:{ trends:3 }\"\n^aggregator (>) \"compile:report\" → { sections:3, pages:12 }\n^aggregator (>) @fs \"write:/output/report.pdf\"\n%db.tasks (+) { task:\"build-report\", status:\"complete\", agents:3, time:*now }", "tags": ["scx", "agents", "collaboration", "ai"]}
{"instruction": "Write SCX for snapshot branching: save state, try mutation, rollback if failed.", "input": "", "output": "@snapshot (>) \"save:branch-point:bp_001\"\n#player (>) $inventory \"add:item:experimental-serum\"\n#player (>) \"use:item:experimental-serum\"\n@validator (>) \"check:player:health\" → { status:\"critical\", health:5 }\n@snapshot (>) \"rollback:bp_001\"  # revert to pre-serum state\n!ui (>) \"warn:action-reverted:experimental-serum\"\n%db.logs (+) { event:\"rollback\", branch:\"bp_001\", reason:\"critical-health\", time:*now }", "tags": ["scx", "snapshot", "rollback", "actions"]}
